Stream Ciphers
- Block Cipher
    Fixed-sizes they encrypt , stateless,
    requires "modes" to securely process longer messages (Chain Block Cipher)
- Stream Cipher
    Retains state from processing past messages
    Common approach: one time pad on the cheap
    ex: AES block cipher in counter mode
    - XORs plaintext with some "random" bits
    - diff from OTP: Not XORED with KEY!
    - "Random" bits output by PRNG
    From stream:
    Encrypt (similar to one time pad), public IV
    (always changed after each encryption)
    E(M, K) = PRNG(K, IV) (XOR) M = C
    Decrypt:
    D(C,K) = PRNG(K, IV) (XOR) C
    since PRNG can do any length bit, not restricted to key size

Streams from PRNGs

        (small) K, IV               (small) K, IV
                |                           |
               PRNG                        PRNG
                |                           |
            keystream                  keystream
                |                           |
     Mi -> (XOR) --------(IV, Ci)------->(XOR)-> Mi
     Alice                                       Bob

Formuliacly:
Sender and receiver have access to the key K.

Sender:
        PRNG(K, IV) (XOR) Mi = Ci
        Sends IV along with Cis
Receiver:
        Receives IV along with Ci
        PRNG(K, IV) (XOR) Ci = Mi

Building a cryptographically strong PRNG
- Simple design for PRNG
    State: SEED and N (# of samples so far)
    PRNG(SEED) = {return AES-128_{SEED}(++N)} // block cypher, E: {0,1}^b x {0,1}^k
        Encrypt counter # of calls using SEED as key
        AES-128 has random permutation of 128 bits,
        so small change from N to N + 1 produces unpredictable output
    Is deterministic, since sending once and then again after with same key
    (SEED) will result in same encryption -> one time pad key exchange problem
- Alternate design (IV acts as a source of randomness)
    State: SEED, N, IV
    PRNG(SEED) = {return AES-128_{SEED}(++N(XOR)IV)}

Integrity and Authentication
Integrity:
- Bob can verify what he received is exactly what Alice sent
Authentication:
- Bob can verify message is from and generated by Alice

Mallory the Manipulator (active attacker)
- Relay messages throuugh mallory
- MITM attack

Verifying Integrity and Authentication
- Combine cryptographically secure hash functions and symmetric-key cryptography
    Message Auth Codes (MAC) established integrity of msg
    For each msg, can only create a valid MAC with a shared key K
    Auth dervies from ensuring that only Alice and Bob have K

Collision Resistance implies 2nd preimage resistance

MD5   broken
SHA-1 broken
SHA-256 not currently broken
But anyone can compute hash! Not secure since over insecure channels

MACS approach
- Symmetric-Key approach for integrity
    - Use shared secret key K
